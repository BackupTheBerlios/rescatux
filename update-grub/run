#!/bin/bash
# Rescapp Update-grub run script
# Copyright Adrian Gibanel Lopez
# Licensed under the GNU PUBLIC LICENSE 3.0
source ${RESCATUX_LIB_FILE}
set -x
set -v


# First of all let decide the user to rename their hard disks to meet their possible different mapping at hard disk installation  - BEGIN

DETECTED_HARD_DISKS=$(rtux_Get_System_HardDisks)

mkdir /dev/new

# Let's loop on detected hard disks so that user can rename them
for n_hard_disk in ${DETECTED_HARD_DISKS} ; do

  new_hard_disk_name=$(zenity ${ZENITY_COMMON_OPTIONS}  --entry --title="Rename hard disk if needed" --text="Detected: ${n_hard_disk}" --entry-text="${n_hard_disk}");

  ln -s /dev/${n_hard_disk} /dev/new/${new_hard_disk_name}
  for n_partition in /dev/* ; do
    actual_partition=$(echo "${n_partition}" | sed 's%/dev/%%g')
    test_partition=$(echo ${actual_partition} | grep ${n_hard_disk})
    partition_number=$(echo ${test_partition} | sed "s%${n_hard_disk}%%g")
    if [[ "${test_partition}x" != "x" ]] ; then
	ln -s /dev/${n_hard_disk}${partition_number} /dev/new/${new_hard_disk_name}${partition_number}
    fi
  done
done


# We are going to redefine TARGET_PARTITIONS with user choosen hard disks
TARGET_PARTITIONS=""
# Let's move some partitions
for n_partition in /dev/new/* ; do
  new_partition=$(echo $n_partition | sed 's%/dev/new/%%g')
  old_partition=$(readlink ${n_partition})
  mv $old_partition /dev/${new_partition}
  TARGET_PARTITIONS="${TARGET_PARTITIONS} ${new_partition}"

done




# First of all let decide the user to rename their hard disks to meet their possible different mapping at hard disk installation  - END

# TODO: Program check runtime (Maybe to be stolen from bootinfoscript)




echo $TARGET_PARTITIONS

SBIN_GRUB_PARTITIONS=""
RESCATUX_ROOT_MNT=/mnt/rescatux
LINUX_OS_DETECTOR="/etc/issue"
#GRUB_INSTALL_BINARY=/etc/issue
GRUB_INSTALL_BINARY=grub-install
UPDATE_GRUB_BINARY=update-grub

for n_partition in ${TARGET_PARTITIONS}; do
	TMP_MNT_PARTITION=${RESCATUX_ROOT_MNT}/${n_partition}
	TMP_DEV_PARTITION=/dev/${n_partition}
	mkdir --parents ${TMP_MNT_PARTITION}
	if $(mount -t auto ${TMP_DEV_PARTITION} ${TMP_MNT_PARTITION} 2> /dev/null) ; then
		#echo -e -n "Detectada particion: ${n_partition}\n";
		if [[ -e ${TMP_MNT_PARTITION}${LINUX_OS_DETECTOR} ]] ; then
		  #echo -e -n "Detectado grub-install en particion: ${n_partition}\n"
		  SBIN_GRUB_PARTITIONS="${SBIN_GRUB_PARTITIONS} ${n_partition}"
		fi
		umount ${TMP_MNT_PARTITION};
	fi
done

echo -e -n "Detected grub-install partitions: ${SBIN_GRUB_PARTITIONS}\n"





# MAIN PROGRAM

# TODO: FETCH WIDTH AND HEIGHT FROM COMMAND LINE OR SO

GRUB_INSTALL_MBR_WIDTH="600"
GRUB_INSTALL_MBR_HEIGHT="400"
ZENITY_COMMON_OPTIONS="--width=${GRUB_INSTALL_MBR_WIDTH} --height=${GRUB_INSTALL_MBR_HEIGHT}"

TMP_FOLDER="/tmp"
DEVICE_MAP_NUMBERED_FILE="${TMP_FOLDER}/device.map.numbered"
DEVICE_MAP_RESCATUX_STR="device.map.rescatux"
DEVICE_MAP_BACKUP_STR="device.map.rescatux.backup"

#alias zenity = 'zenity ${ZENITY_COMMON_OPTIONS}' # It does not seem to work
# Select one of the partitions - BEGIN

n=0
LIST_VALUES=""
DESC_VALUES=""
for n_partition in ${SBIN_GRUB_PARTITIONS}; do
  issue_value=`etc_issue ${n_partition}`
  issue_value=$(echo $issue_value | sed 's/\ /\-/')
  issue_value=$(echo $issue_value | sed 's/ /\-/')
  
  if [[ n -eq 0 ]] ; then
    LIST_VALUES="TRUE ${n_partition} ${issue_value}"
  else
    LIST_VALUES="${LIST_VALUES} FALSE ${n_partition} ${issue_value}"
  fi
let n=n+1
done

echo -e -n "a: $LIST_VALUES\n"

ans=$(zenity ${ZENITY_COMMON_OPTIONS}  --list  --text "Which partition is your main GNU/Linux?" --radiolist  --column "Select" --column "Partition" --column "Desc" ${LIST_VALUES}); echo $ans
# Lets suppose that selected partition is: sda3
SELECTED_PARTITION="$ans"
# Select one of the partitions - END


DETECTED_HARD_DISKS=""
ans=$(echo ${TARGET_PARTITIONS} | sed 's/[0-9][0-9]*//g' | tr ' ' '\n' | uniq | tr '\n' ' ')
DETECTED_HARD_DISKS="$ans"
echo -e -n "DEBUG: detected hard disks: ${DETECTED_HARD_DISKS}\n"

# Parse hard disks - BEGIN
n=0
HD_LIST_VALUES=""
for n_hard_disk in ${DETECTED_HARD_DISKS}; do
  
  if [[ ${n} -eq 0 ]] ; then
    HD_LIST_VALUES="TRUE ${n_hard_disk} `/sbin/fdisk -l /dev/${n_hard_disk} | egrep 'Disk.*bytes' | awk '{ sub(/,/,"");  print $3 "-" $4 }'`"
  else
    HD_LIST_VALUES="${HD_LIST_VALUES} FALSE ${n_hard_disk} `/sbin/fdisk -l /dev/${n_hard_disk} | egrep 'Disk.*bytes' | awk '{ sub(/,/,"");  print $3 "-" $4 }'`"
  fi
let n=n+1
done

TOTAL_HD_NUMBER="${n}"

# Parse hard disks - END

n_partition=${SELECTED_PARTITION}

TMP_MNT_PARTITION=${RESCATUX_ROOT_MNT}/${n_partition}
        TMP_DEV_PARTITION=/dev/${n_partition}
        mkdir --parents ${TMP_MNT_PARTITION}
        if $(mount -t auto ${TMP_DEV_PARTITION} ${TMP_MNT_PARTITION} 2> /dev/null) ; then
		mount -o bind /dev ${TMP_MNT_PARTITION}/dev
		mount -o bind /proc ${TMP_MNT_PARTITION}/proc
		mount -o bind /sys ${TMP_MNT_PARTITION}/sys


                #echo -e -n "Detected partition is: ${n_partition}\n";
                if [[ -e ${TMP_MNT_PARTITION}${LINUX_OS_DETECTOR} ]] ; then



			# Generate temporal device.map file in / (Chroot's root but outside chroot) - TODO - BEGIN
			    # (Fetch hard disks detected and show to the user. - TODO - BEGIN
			    # Tell them that they are going to be asked to choose which it is #1, #2,...)
			    ans=$(zenity ${ZENITY_COMMON_OPTIONS}  --list  --text "These are detected hard disks. Prepare to order them according to boot order. Press OK to continue." --radiolist  --column "Select" --column "Hard Disk" --column "Size" ${HD_LIST_VALUES});			      
			    # (Fetch hard disks detected and show to the user. - TODO - END
			    # Tell them that they are going to be asked to choose which it is #1, #2,...)
			    # LOOP - Show hard disk and ask position - TODO - BEGIN
			    echo "" > ${DEVICE_MAP_NUMBERED_FILE}
			    n=1
			    HD_LIST_VALUES=""
			    for n_hard_disk in ${DETECTED_HARD_DISKS}; do
				m=1
				for m_hard_disk in ${DETECTED_HARD_DISKS}; do			      
				  if [[ m -eq 1 ]] ; then
				    HD_LIST_VALUES="TRUE ${m} ${n_hard_disk} `/sbin/fdisk -l /dev/${n_hard_disk} | egrep 'Disk.*bytes' | awk '{ sub(/,/,"");  print $3 "-" $4 }'`"
				  else
				    HD_LIST_VALUES="${HD_LIST_VALUES} FALSE ${m} ${n_hard_disk} `/sbin/fdisk -l /dev/${n_hard_disk} | egrep 'Disk.*bytes' | awk '{ sub(/,/,"");  print $3 "-" $4 }'`"
				  fi
				  let m=m+1
				done
				# Ask position - TODO - BEGIN
				ans=$(zenity ${ZENITY_COMMON_OPTIONS}  --list  --text "Which is the right position for this hard disk?" --radiolist  --column "Select" --column "Position" --column "Hard Disk" --column "Size" ${HD_LIST_VALUES}); 
				echo $ans

				SELECTED_POSITION=$ans
				# Ask position - TODO - END
				# Generate temporal file with order - TODO - BEGIN
				echo -e -n "${SELECTED_POSITION} (hd$(( ${SELECTED_POSITION} - 1 ))) /dev/${n_hard_disk}\n" >> ${DEVICE_MAP_NUMBERED_FILE}
				# Generate temporal file with order - TODO - END
				let n=n+1
			    done
			      # Generate a temporal txt file that begins with a number in first column
			    # LOOP - Show hard disk and ask position - TODO - END
			    # Read the temporal txt file, sort by first column and generate device.map file
			    cat ${DEVICE_MAP_NUMBERED_FILE} | sort | awk '{printf("%s\t%s\n",$2,$3);}' > ${TMP_MNT_PARTITION}/${DEVICE_MAP_RESCATUX_STR}
			# Generate temporal device.map file in / (Chroot's root but outside chroot) - TODO - END


			# TODO: Improve with a cat command ended with a EOF mark
			echo -e -n "mount -a" > ${TMP_MNT_PARTITION}/tmp/$$.sh
			echo -e -n "\n" >> ${TMP_MNT_PARTITION}/tmp/$$.sh


			# Backup current device.map file (inside chroot) - TODO - BEGIN
			echo -e -n "cp /boot/grub/device.map /boot/grub/${DEVICE_MAP_BACKUP_STR}" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
			echo -e -n "\n" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
			# Backup current device.map file (inside chroot) - TODO - END

			# Overwrite current device.map file with temporal device.map (inside chroot) - TODO - BEGIN
			echo -e -n "cp /${DEVICE_MAP_RESCATUX_STR} /boot/grub/device.map" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
			echo -e -n "\n" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
			# Overwrite current device.map file with temporal device.map (inside chroot) - TODO - END
			echo -e -n "${UPDATE_GRUB_BINARY}" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
			echo -e -n "\n" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
			echo -e -n "UPDATE_GRUB_OUTPUT=\$?" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
 			echo -e -n "\n" >> ${TMP_MNT_PARTITION}/tmp/$$.sh

			# Restore current device.map file - TODO - BEGIN
			echo -e -n "cp /boot/grub/${DEVICE_MAP_BACKUP_STR} /boot/grub/device.map" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
			echo -e -n "\n" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
			# Restore current device.map file - TODO - END
			# Delete temporal and backup device.map files- TODO - BEGIN
			echo -e -n "rm /boot/grub/${DEVICE_MAP_BACKUP_STR}" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
			echo -e -n "\n" >> ${TMP_MNT_PARTITION}/tmp/$$.sh

			echo -e -n "rm /${DEVICE_MAP_RESCATUX_STR}" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
			echo -e -n "\n" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
			# Delete temporal and backup device.map files- TODO - END

			echo -e -n "umount -a" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
			echo -e -n "\n" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
			echo -e -n "exit \${UPDATE_GRUB_OUTPUT}" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
			echo -e -n "\n" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
			chmod +x ${TMP_MNT_PARTITION}/tmp/$$.sh

			# TODO: Let the user use other than now hard-coded /bin/bash
			if chroot ${TMP_MNT_PARTITION} /bin/bash /tmp/$$.sh ; then
				zenity ${ZENITY_COMMON_OPTIONS} --info --title="Success!" --text="Grub configuration was updated OK! :)";
			else
				zenity ${ZENITY_COMMON_OPTIONS} --info --title="Failure!" --text="Grub configuration update went wrong! :(";
			fi
			mount -t auto -o remount,rw ${TMP_DEV_PARTITION} ${TMP_MNT_PARTITION} # Workaround
			rm ${TMP_MNT_PARTITION}/tmp/$$.sh
			

                fi
		umount ${TMP_MNT_PARTITION}/sys
		umount ${TMP_MNT_PARTITION}/proc
		umount ${TMP_MNT_PARTITION}/dev
                umount ${TMP_MNT_PARTITION};
        fi



#
