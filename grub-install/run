#!/bin/bash
# Rescapp Grub-install run script
# Copyright Adrian Gibanel Lopez
# Licensed under the GNU PUBLIC LICENSE 3.0

source ${RESCATUX_LIB_FILE}

set -x
set -v

# Install Grub from the choosen Linux partition to the choosen hard disk
# 1 parametre = Selected hard disk
# 2 parametre = Selected partition
# While it is being run user is shown the hard disks
# and it is asked to order them
function rtux_Grub_Install () {
# TODO: Extract last user interaction (Success/Failure)
# So that this function returns being successful or not

  local SELECTED_HARD_DISK="$1"
  local SELECTED_PARTITION="$2"

  local DETECTED_HARD_DISKS=$(rtux_Get_System_HardDisks);

  local SELECTED_HARD_DISK_DEV="/dev/${SELECTED_HARD_DISK}"
  local n_partition=${SELECTED_PARTITION}

  local TMP_MNT_PARTITION=${RESCATUX_ROOT_MNT}/${n_partition}
  local TMP_DEV_PARTITION=/dev/${n_partition}
  mkdir --parents ${TMP_MNT_PARTITION}
  if $(mount -t auto ${TMP_DEV_PARTITION} ${TMP_MNT_PARTITION} 2> /dev/null)
    then
    mount -o bind /dev ${TMP_MNT_PARTITION}/dev
    mount -o bind /proc ${TMP_MNT_PARTITION}/proc
    mount -o bind /sys ${TMP_MNT_PARTITION}/sys

    if [[ -e ${TMP_MNT_PARTITION}${LINUX_OS_DETECTOR} ]] ; then
      # Generate temporal device.map file in / (Chroot's root but outside chroot) - TODO - BEGIN
      # (Fetch hard disks detected and show to the user. - TODO - BEGIN
      # Tell them that they are going to be asked to choose which it is #1, #2,...)
      $(rtux_Choose_Hard_Disk ${PREPARE_ORDER_HDS_STR});

      # (Fetch hard disks detected and show to the user. - TODO - END
      # Tell them that they are going to be asked to choose which it is #1, #2,...)
      # LOOP - Show hard disk and ask position - TODO - BEGIN
      echo "" > ${DEVICE_MAP_NUMBERED_FILE}
      local n=1
      local HD_LIST_VALUES=""
      for n_hard_disk in ${DETECTED_HARD_DISKS}; do
	m=1
	for m_hard_disk in ${DETECTED_HARD_DISKS}; do			      
	  if [[ m -eq 1 ]] ; then
	    HD_LIST_VALUES="TRUE ${m} ${n_hard_disk} \
	    `/sbin/fdisk -l /dev/${n_hard_disk} \
		      | egrep 'Disk.*bytes' \
		      | awk '{ sub(/,/,"");  print $3 "-" $4 }'`"
	  else
	    HD_LIST_VALUES="${HD_LIST_VALUES} FALSE ${m} ${n_hard_disk} \
	    `/sbin/fdisk -l /dev/${n_hard_disk} \
		      | egrep 'Disk.*bytes' \
		      | awk '{ sub(/,/,"");  print $3 "-" $4 }'`"
	  fi
	  let m=m+1
	done

	# Ask position - BEGIN
	local SELECTED_POSITION=$(zenity ${ZENITY_COMMON_OPTIONS} \
	      --list  \
	      --text "${RIGHT_HD_POSITION_STR}" \
	      --radiolist  \
	      --column "${SELECT_STR}" \
	      --column "${POSITION_STR}" \
	      --column "${HARDDISK_STR}" \
	      ${HD_LIST_VALUES}); 

	# Ask position - END
	# Generate temporal file with order - TODO - BEGIN
	echo -e -n "${SELECTED_POSITION} (hd$(( ${SELECTED_POSITION} - 1 ))) /dev/${n_hard_disk}\n" >> ${DEVICE_MAP_NUMBERED_FILE}
	# Generate temporal file with order - TODO - END
	let n=n+1
      done
      # Generate a temporal txt file that begins with a number in first column
      # LOOP - Show hard disk and ask position - TODO - END
      # Read the temporal txt file, sort by first column and generate device.map file
      cat ${DEVICE_MAP_NUMBERED_FILE} | sort | awk '{printf("%s\t%s\n",$2,$3);}' > ${TMP_MNT_PARTITION}/${DEVICE_MAP_RESCATUX_STR}
      # Generate temporal device.map file in / (Chroot's root but outside chroot) - TODO - END


      # TODO: Improve with a cat command ended with a EOF mark
      local TMP_SCRIPT="/tmp/$$.sh"
      local TMP_MNT_PARTITION_SCRIPT="${TMP_MNT_PARTITION}${TMP_SCRIPT}"

      cat << EOF > ${TMP_MNT_PARTITION}${TMP_SCRIPT}
	mount -a
	# Backup current device.map file (inside chroot) - TODO - BEGIN
	cp /boot/grub/device.map /boot/grub/${DEVICE_MAP_BACKUP_STR}
	# Backup current device.map file (inside chroot) - TODO - END

	# Overwrite current device.map file with temporal device.map (inside chroot) - TODO - BEGIN
	cp /${DEVICE_MAP_RESCATUX_STR} /boot/grub/device.map
	# Overwrite current device.map file with temporal device.map (inside chroot) - TODO - END
	${GRUB_INSTALL_BINARY} ${SELECTED_HARD_DISK_DEV}
	GRUB_INSTALL_OUTPUT=\$?
	# Restore current device.map file - BEGIN
	cp /boot/grub/${DEVICE_MAP_BACKUP_STR} /boot/grub/device.map
	# Restore current device.map file - END
	# Delete temporal and backup device.map files- TODO - BEGIN
	rm /boot/grub/${DEVICE_MAP_BACKUP_STR}
	rm /${DEVICE_MAP_RESCATUX_STR}
	# Delete temporal and backup device.map files- TODO - END
	umount -a
	exit \${GRUB_INSTALL_OUTPUT}
EOF
      


      chmod +x ${TMP_MNT_PARTITION_SCRIPT}

      # TODO: Let the user use other than now hard-coded /bin/bash
      if chroot ${TMP_MNT_PARTITION} /bin/bash ${TMP_SCRIPT} ; then
	rtux_Message_Success ${GRUB_INSTALLED_OK_STR}
      else
	rtux_Message_Failure ${GRUB_NOT_INSTALLED_STR}
      fi
      mount -t auto -o remount,rw ${TMP_DEV_PARTITION} ${TMP_MNT_PARTITION} # Workaround
      rm ${TMP_MNT_PARTITION_SCRIPT}
		  
    fi # Linux detector was found
    umount ${TMP_MNT_PARTITION}/sys
    umount ${TMP_MNT_PARTITION}/proc
    umount ${TMP_MNT_PARTITION}/dev
    umount ${TMP_MNT_PARTITION};
  fi # Partition was mounted ok

} # function rtux_Grub_Install ()

# TODO: Program check runtime (Maybe to be stolen from bootinfoscript)

SBIN_GRUB_PARTITIONS="$(rtux_Get_Linux_Os_Partitions)"

# MAIN PROGRAM

# TODO: FETCH WIDTH AND HEIGHT FROM COMMAND LINE OR SO

GRUB_INSTALL_MBR_WIDTH="${RESCAPP_WIDTH}"
GRUB_INSTALL_MBR_HEIGHT="${RESCAPP_HEIGHT}"


GRUB_INSTALLED_OK_STR="Grub was installed OK! :)"
GRUB_NOT_INSTALLED_STR="Grub was not installed. Something went wrong! :("
WHICH_HARD_DISK_INSTALL_GRUB_STR="Which hard disk to install Grub on?"

SELECTED_PARTITION=$(rtux_Choose_Linux_partition);



SELECTED_HARD_DISK=$(rtux_Choose_Hard_Disk ${WHICH_HARD_DISK_INSTALL_GRUB_STR});

rtux_Grub_Install ${SELECTED_HARD_DISK} ${SELECTED_PARTITION}


