#!/bin/bash
# Rescapp Grub-install run script
# Copyright Adrian Gibanel Lopez
# Licensed under the GNU PUBLIC LICENSE 3.0

source ${RESCATUX_LIB_FILE}

set -x
set -v

# TODO: Program check runtime (Maybe to be stolen from bootinfoscript)

TARGET_PARTITIONS=$(awk '{print $4}' ${PROC_PARTITIONS_FILE} | sed -e '/name/d' -e '/^$/d' -e '/[1-9]/!d')

SBIN_GRUB_PARTITIONS=""

for n_partition in ${TARGET_PARTITIONS}; do
  TMP_MNT_PARTITION=${RESCATUX_ROOT_MNT}/${n_partition}
  TMP_DEV_PARTITION=/dev/${n_partition}
  mkdir --parents ${TMP_MNT_PARTITION}

  if $(mount -t auto ${TMP_DEV_PARTITION} ${TMP_MNT_PARTITION} 2> /dev/null) ; then
    if [[ -e ${TMP_MNT_PARTITION}${LINUX_OS_DETECTOR} ]] ; then
      SBIN_GRUB_PARTITIONS="${SBIN_GRUB_PARTITIONS} ${n_partition}"
    fi
    umount ${TMP_MNT_PARTITION};
  fi
done

function etc_issue() {
  local PARTITION_TO_MOUNT=$1
  local n_partition=${PARTITION_TO_MOUNT}

  TMP_MNT_PARTITION=${RESCATUX_ROOT_MNT}/${n_partition}
  TMP_DEV_PARTITION=/dev/${n_partition}
  mkdir --parents ${TMP_MNT_PARTITION}
  if $(mount -t auto ${TMP_DEV_PARTITION} ${TMP_MNT_PARTITION} 2> /dev/null) ; then
    if [[ -e ${TMP_MNT_PARTITION}${ETC_ISSUE_PATH} ]] ; then
      echo $(head -n 1 ${TMP_MNT_PARTITION}${ETC_ISSUE_PATH} |\
	sed -e 's/\\. //g' -e 's/\\.//g' -e 's/^[ \t]*//' -e 's/\ /-/g' -e 's/\ \ /-/g' -e 's/\n/-/g')
    else
      echo "Not detected"
    fi
    umount ${TMP_MNT_PARTITION};
  fi
} # function etc_issue() end


# MAIN PROGRAM

# TODO: FETCH WIDTH AND HEIGHT FROM COMMAND LINE OR SO

GRUB_INSTALL_MBR_WIDTH="${RESCAPP_WIDTH}"
GRUB_INSTALL_MBR_HEIGHT="${RESCAPP_HEIGHT}"


DEVICE_MAP_NUMBERED_FILE="${TMP_FOLDER}/device.map.numbered"
DEVICE_MAP_RESCATUX_STR="device.map.rescatux"
DEVICE_MAP_BACKUP_STR="device.map.rescatux.backup"

GRUB_INSTALLED_OK_STR="Grub was installed OK! :)"
GRUB_NOT_INSTALLED_STR="Grub was not installed. Something went wrong! :("
WHICH_HARD_DISK_INSTALL_GRUB_STR="Which hard disk to install Grub on?"

# Select one of the partitions - BEGIN

n=0
LIST_VALUES=""
DESC_VALUES=""
for n_partition in ${SBIN_GRUB_PARTITIONS}; do
  issue_value=`etc_issue ${n_partition}`
  issue_value=$(echo $issue_value | sed 's/\ /\-/')
  issue_value=$(echo $issue_value | sed 's/ /\-/')
  
  if [[ n -eq 0 ]] ; then
    LIST_VALUES="TRUE ${n_partition} ${issue_value}"
  else
    LIST_VALUES="${LIST_VALUES} FALSE ${n_partition} ${issue_value}"
  fi
let n=n+1
done

echo -e -n "a: $LIST_VALUES\n"

ans=$(zenity ${ZENITY_COMMON_OPTIONS}  \
      --list  \
      --text "${WHICH_PARTITION_STR}" \
      --radiolist  \
      --column "${SELECT_STR}" \
      --column "${PARTITION_STR}" \
      --column "${DESCRIPTION_STR}" ${LIST_VALUES});

SELECTED_PARTITION="$ans"
# Select one of the partitions - END


DETECTED_HARD_DISKS=""
ans=$(echo ${TARGET_PARTITIONS} | sed 's/[0-9][0-9]*//g' | tr ' ' '\n' | uniq | tr '\n' ' ')
DETECTED_HARD_DISKS="$ans"

# Select one of the hard disks - BEGIN
n=0
HD_LIST_VALUES=""
for n_hard_disk in ${DETECTED_HARD_DISKS}; do
  if [[ ${n} -eq 0 ]] ; then
    HD_LIST_VALUES="TRUE ${n_hard_disk} `${FDISK_COMMAND} -l \
    | egrep ${n_hard_disk} \
    | egrep 'Disk.*bytes' \
    | awk '{ sub(/,/,"");  print $3 "-" $4 }'`"
  else
    HD_LIST_VALUES="${HD_LIST_VALUES} FALSE ${n_hard_disk} `${FDISK_COMMAND} -l \
    | egrep ${n_hard_disk} \
    | egrep 'Disk.*bytes' \
    | awk '{ sub(/,/,"");  print $3 "-" $4 }'`"
  fi
  let n=n+1
done

TOTAL_HD_NUMBER="${n}"

ans=$(zenity ${ZENITY_COMMON_OPTIONS}  \
      --list  \
      --text "${WHICH_HARD_DISK_INSTALL_GRUB_STR}" \
      --radiolist  \
      --column "${SELECT_STR}" \
      --column "${HARDDISK_STR}" \
      --column "${SIZE_STR}" ${HD_LIST_VALUES}); 

SELECTED_HARD_DISK=$ans


# Select one of the hard disks - END

# TODO: TO BE IMPROVED WITH A FUNCTION
SELECTED_HARD_DISK_DEV="/dev/${SELECTED_HARD_DISK}"
n_partition=${SELECTED_PARTITION}

TMP_MNT_PARTITION=${RESCATUX_ROOT_MNT}/${n_partition}
TMP_DEV_PARTITION=/dev/${n_partition}
mkdir --parents ${TMP_MNT_PARTITION}
if $(mount -t auto ${TMP_DEV_PARTITION} ${TMP_MNT_PARTITION} 2> /dev/null) ; then
  mount -o bind /dev ${TMP_MNT_PARTITION}/dev
  mount -o bind /proc ${TMP_MNT_PARTITION}/proc
  mount -o bind /sys ${TMP_MNT_PARTITION}/sys

  if [[ -e ${TMP_MNT_PARTITION}${LINUX_OS_DETECTOR} ]] ; then
    # Generate temporal device.map file in / (Chroot's root but outside chroot) - TODO - BEGIN
    # (Fetch hard disks detected and show to the user. - TODO - BEGIN
    # Tell them that they are going to be asked to choose which it is #1, #2,...)
    ans=$(zenity ${ZENITY_COMMON_OPTIONS} \
	  --list  \
	  --text "${PREPARE_ORDER_HDS_STR}" \
	  --radiolist  \
	  --column "${SELECT_STR}" \
	  --column "${HARDDISK_STR}" \
	  --column "${SIZE_STR}" \
	  ${HD_LIST_VALUES});

    # (Fetch hard disks detected and show to the user. - TODO - END
    # Tell them that they are going to be asked to choose which it is #1, #2,...)
    # LOOP - Show hard disk and ask position - TODO - BEGIN
    echo "" > ${DEVICE_MAP_NUMBERED_FILE}
    n=1
    HD_LIST_VALUES=""
    for n_hard_disk in ${DETECTED_HARD_DISKS}; do
      m=1
      for m_hard_disk in ${DETECTED_HARD_DISKS}; do			      
        if [[ m -eq 1 ]] ; then
          HD_LIST_VALUES="TRUE ${m} ${n_hard_disk}"
        else
          HD_LIST_VALUES="${HD_LIST_VALUES} FALSE ${m} ${n_hard_disk}"
        fi
        let m=m+1
      done

      # Ask position - TODO - BEGIN
      ans=$(zenity ${ZENITY_COMMON_OPTIONS} \
	    --list  \
	    --text "${RIGHT_HD_POSITION_STR}" \
	    --radiolist  \
	    --column "${SELECT_STR}" \
	    --column "${POSITION_STR}" \
	    --column "${HARDDISK_STR}" \
	    ${HD_LIST_VALUES}); 
      SELECTED_POSITION=$ans
      # Ask position - TODO - END
      # Generate temporal file with order - TODO - BEGIN
      echo -e -n "${SELECTED_POSITION} (hd$(( ${SELECTED_POSITION} - 1 ))) /dev/${n_hard_disk}\n" >> ${DEVICE_MAP_NUMBERED_FILE}
      # Generate temporal file with order - TODO - END
      let n=n+1
    done
    # Generate a temporal txt file that begins with a number in first column
    # LOOP - Show hard disk and ask position - TODO - END
    # Read the temporal txt file, sort by first column and generate device.map file
    cat ${DEVICE_MAP_NUMBERED_FILE} | sort | awk '{printf("%s\t%s\n",$2,$3);}' > ${TMP_MNT_PARTITION}/${DEVICE_MAP_RESCATUX_STR}
    # Generate temporal device.map file in / (Chroot's root but outside chroot) - TODO - END


    # TODO: Improve with a cat command ended with a EOF mark
    echo -e -n "mount -a" > ${TMP_MNT_PARTITION}/tmp/$$.sh
    echo -e -n "\n" >> ${TMP_MNT_PARTITION}/tmp/$$.sh


    # Backup current device.map file (inside chroot) - TODO - BEGIN
    echo -e -n "cp /boot/grub/device.map /boot/grub/${DEVICE_MAP_BACKUP_STR}" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
    echo -e -n "\n" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
    # Backup current device.map file (inside chroot) - TODO - END

    # Overwrite current device.map file with temporal device.map (inside chroot) - TODO - BEGIN
    echo -e -n "cp /${DEVICE_MAP_RESCATUX_STR} /boot/grub/device.map" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
    echo -e -n "\n" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
    # Overwrite current device.map file with temporal device.map (inside chroot) - TODO - END
    echo -e -n "${GRUB_INSTALL_BINARY} ${SELECTED_HARD_DISK_DEV}" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
    echo -e -n "\n" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
    echo -e -n "GRUB_INSTALL_OUTPUT=\$?" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
    echo -e -n "\n" >> ${TMP_MNT_PARTITION}/tmp/$$.sh

    # Restore current device.map file - TODO - BEGIN
    echo -e -n "cp /boot/grub/${DEVICE_MAP_BACKUP_STR} /boot/grub/device.map" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
    echo -e -n "\n" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
    # Restore current device.map file - TODO - END
    # Delete temporal and backup device.map files- TODO - BEGIN
    echo -e -n "rm /boot/grub/${DEVICE_MAP_BACKUP_STR}" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
    echo -e -n "\n" >> ${TMP_MNT_PARTITION}/tmp/$$.sh

    echo -e -n "rm /${DEVICE_MAP_RESCATUX_STR}" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
    echo -e -n "\n" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
    # Delete temporal and backup device.map files- TODO - END

    echo -e -n "umount -a" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
    echo -e -n "\n" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
    echo -e -n "exit \${GRUB_INSTALL_OUTPUT}" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
    echo -e -n "\n" >> ${TMP_MNT_PARTITION}/tmp/$$.sh
    chmod +x ${TMP_MNT_PARTITION}/tmp/$$.sh

    # TODO: Let the user use other than now hard-coded /bin/bash
    if chroot ${TMP_MNT_PARTITION} /bin/bash /tmp/$$.sh ; then
      zenity ${ZENITY_COMMON_OPTIONS} \
	--info \
	--title="${SUCCESS_STR}" \
	--text="${GRUB_INSTALLED_OK_STR}";
    else
      zenity ${ZENITY_COMMON_OPTIONS} \
	--info \
	--title="${FAILURE_STR}" \
	--text="${GRUB_NOT_INSTALLED_STR}";
    fi
    mount -t auto -o remount,rw ${TMP_DEV_PARTITION} ${TMP_MNT_PARTITION} # Workaround
    rm ${TMP_MNT_PARTITION}/tmp/$$.sh
		
  fi # Linux detector was found
  umount ${TMP_MNT_PARTITION}/sys
  umount ${TMP_MNT_PARTITION}/proc
  umount ${TMP_MNT_PARTITION}/dev
  umount ${TMP_MNT_PARTITION};
fi # Partition was mounted ok



#
